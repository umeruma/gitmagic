== 導入 ==

私はバージョン管理について紹介するために比喩を使います。まともな説明は、 http://en.wikipedia.org/wiki/Revision_control[修正管理についてのウィキペディアの記事]をご覧ください。

=== 仕事は遊び ===

私はコンピュータゲームで遊ぶことに人生のほぼ全てを費やしてきました。それに対して、バージョン管理システムを使い始めたのは大人になってからでした。私に限った話ではないと思いますし、この二つを比べることはそのコンセプトを説明しやすく、また理解しやすくするでしょう。

あなたのコード、またはドキュメントの編集を、ゲームで遊ぶことのように考えてみてください。かつて、たくさん進めてきたのであれば、セーブしたことでしょう。そうするように、あなたは信頼できるエディタの「保存する」ボタンをクリックします。

しかしこれは古いバージョンを上書きます。かつてのオールドスクールゲームに一つのセーブスロットしかなかったようなものです: 当然セーブではきましたが、古い状態に戻ることはもうできませんでした。 それは残念なことでした、あなたの過去のセーブポイントはいつの日かまた戻りたい、ゲームの並外れて楽しい部分のすぐそばだったかもしれません。もっと悪ければ、今のセーブが勝てない状態にあるのであれば、再スタートしなければいけません。

=== バージョン管理 ===

編集しているとき、古いバージョンをとっておきたければ、あなたは別のファイルとして「名前をつけて保存…」したり、保存する前にまずファイルをどこか別の場所へコピーすることができます。省スペースのためにそれらを圧縮することも可能です。これはバージョン管理としては原始的で多くの労力を必要とします。コンピュータゲームは遠い昔にこの問題を改善しており、その多くがタイムスタンプが付いた複数の自動セーブスロットを提供しています。

では問題をより難しくしてみましょう。プロジェクトのソースコードや、ウェブサイトのファイルなど、一緒に扱う多くのファイルがあるとします。すると古いバージョンを保持したいのであれば、ディレクトリ全体をアーカイブしなければいけません。手作業で多くのバージョンを保持するのは不便ですし、すぐに多くのコストがかかるようになります。

いくつかのコンピューターゲームでは、セーブされたゲームは実際にファイルで満ちたディレクトリーで成り立っています。これらのゲームはプレイヤーからその詳細を隠し、このディレクトリの異なるバージョンを管理する便利なインターフェースを提供します。

バージョン管理システムも変わりません。それは色々なものが入ったディレクトリを管理するための素敵なインターフェースを持っています。あなたはディレクトリの状態を頻繁に保存することができ、保存された状態のどれでも後から読み込むことが可能です。ほとんどのコンピューターゲームとは異なり、それらは大抵の場合スペースの節約おいて優れています。一般的に、バージョン間で変更のあるファイルは少数で、そう多くはありません。丸ごと新しくコピーするよりも差分を保持する方が空間が節約されます。

=== 分散型管理 ===

では非常に難しいコンピューターゲームを想像してみましょう。終わらせることが非常に困難であるため、全世界中の多くの経験豊富なゲーマーたちは、力を合わせそれぞれのセーブされたゲームを共有して打ち負かそうと決断しました。スピードランは実際の例です: 同じゲームの異なるレベルに特化したプレイヤーたちが協力することで素晴らしい結果を生み出しています。

どのようにシステムを準備すれば彼らがお互いのセーブを容易に入手できるでしょうか？そして新しいものをアップロードできるでしょうか？

In the old days, every project used centralized version control. A server somewhere held all the saved games. Nobody else did. Every player kept at most a few saved games on their machine. When a player wanted to make progress, they'd download the latest save from the main server, play a while, save and upload back to the server for everyone else to use.


What if a player wanted to get an older saved game for some reason? Maybe the current saved game is in an unwinnable state because somebody forgot to pick up an object back in level three, and they want to find the latest saved game where the game can still be completed. Or maybe they want to compare two older saved games to see how much work a particular player did.

There could be many reasons to want to see an older revision, but the outcome is the same. They have to ask the central server for that old saved game. The more saved games they want, the more they need to communicate.

The new generation of version control systems, of which Git is a member, are known as distributed systems, and can be thought of as a generalization of centralized systems. When players download from the main server they get every saved game, not just the latest one. It's as if they're mirroring the central server.

This initial cloning operation can be expensive, especially if there's a long history, but it pays off in the long run. One immediate benefit is that when an old save is desired for any reason, communication with the central server is unnecessary.

=== A Silly Superstition ===

A popular misconception is that distributed systems are ill-suited for projects requiring an official central repository. Nothing could be further from the truth. Photographing someone does not cause their soul to be stolen. Similarly, cloning the master repository does not diminish its importance.

A good first approximation is that anything a centralized version control system can do, a well-designed distributed system can do better. Network resources are simply costlier than local resources. While we shall later see there are drawbacks to a distributed approach, one is less likely to make erroneous comparisons with this rule of thumb.

A small project may only need a fraction of the features offered by such a
system, but using systems that scale poorly for tiny projects is like using
Roman numerals for calculations involving small numbers.

Moreover, your project may grow beyond your original expectations. Using Git from the outset is like carrying a Swiss army knife even though you mostly use it to open bottles. On the day you desperately need a screwdriver you'll be glad you have more than a plain bottle-opener.

=== Merge Conflicts ===

For this topic, our computer game analogy becomes too thinly stretched. Instead, let us again consider editing a document.

Suppose Alice inserts a line at the beginning of a file, and Bob appends one at the end of his copy. They both upload their changes. Most systems will automatically deduce a reasonable course of action: accept and merge their changes, so both Alice's and Bob's edits are applied.

Now suppose both Alice and Bob have made distinct edits to the same line. Then it is impossible to proceed without human intervention. The second person to upload is informed of a _merge conflict_, and must choose one edit over another, or revise the line entirely.

More complex situations can arise. Version control systems handle the simpler cases themselves, and leave the difficult cases for humans. Usually their behaviour is configurable.
