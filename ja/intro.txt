== 導入 ==

私はバージョン管理について紹介するために比喩を使います。まともな説明は、 http://en.wikipedia.org/wiki/Revision_control[修正管理についてのウィキペディアの記事]をご覧ください。

=== 仕事は遊び ===

私はコンピュータゲームで遊ぶことに人生のほぼ全てを費やしてきました。それに対して、バージョン管理システムを使い始めたのは大人になってからでした。私に限った話ではないと思いますし、この二つを比べることはそのコンセプトを説明しやすく、また理解しやすくするでしょう。

あなたのコード、またはドキュメントの編集を、ゲームで遊ぶことのように考えてみてください。かつて、たくさん進めてきたのであれば、セーブしたことでしょう。そうするように、あなたは信頼できるエディタの「保存する」ボタンをクリックします。

しかしこれは古いバージョンを上書きます。かつてのオールドスクールゲームに一つのセーブスロットしかなかったようなものです: 当然セーブではきましたが、古い状態に戻ることはもうできませんでした。 それは残念なことでした、あなたの過去のセーブポイントはいつの日かまた戻りたい、ゲームの並外れて楽しい部分のすぐそばだったかもしれません。もっと悪ければ、今のセーブが勝てない状態にあるのであれば、再スタートしなければいけません。

=== バージョン管理 ===

編集しているとき、古いバージョンをとっておきたければ、あなたは別のファイルとして「名前をつけて保存…」したり、保存する前にまずファイルをどこか別の場所へコピーすることができます。省スペースのためにそれらを圧縮することも可能です。これはバージョン管理としては原始的で多くの労力を必要とします。コンピュータゲームは遠い昔にこの問題を改善しており、その多くがタイムスタンプが付いた複数の自動セーブスロットを提供しています。

では問題をより難しくしてみましょう。プロジェクトのソースコードや、ウェブサイトのファイルなど、一緒に扱う多くのファイルがあるとします。すると古いバージョンを保持したいのであれば、ディレクトリ全体をアーカイブしなければいけません。手作業で多くのバージョンを保持するのは不便ですし、すぐに多くのコストがかかるようになります。

いくつかのコンピューターゲームでは、セーブされたゲームは実際にファイルで満ちたディレクトリーで成り立っています。これらのゲームはプレイヤーからその詳細を隠し、このディレクトリの異なるバージョンを管理する便利なインターフェースを提供します。

バージョン管理システムも変わりません。それは色々なものが入ったディレクトリを管理するための素敵なインターフェースを持っています。あなたはディレクトリの状態を頻繁に保存することができ、保存された状態のどれでも後から読み込むことが可能です。ほとんどのコンピューターゲームとは異なり、それらは大抵の場合スペースの節約おいて優れています。一般的に、バージョン間で変更のあるファイルは少数で、そう多くはありません。丸ごと新しくコピーするよりも差分を保持する方が空間が節約されます。

=== 分散型管理 ===

では非常に難しいコンピューターゲームを想像してみましょう。終わらせることが非常に困難であるため、全世界中の多くの経験豊富なゲーマーたちは、力を合わせそれぞれのセーブされたゲームを共有して打ち負かそうと決断しました。スピードランは実際の例です: 同じゲームの異なるレベルに特化したプレイヤーたちが協力することで素晴らしい結果を生み出しています。

どのようにシステムを準備すれば彼らがお互いのセーブを容易に入手できるでしょうか？そして新しいものをアップロードできるでしょうか？

かつては、どのプロジェクトも集中型バージョン管理を利用していました。どこかにあるサーバーがセーブされたゲームのすべて保持していました。その他の場所にはありません。全プレーヤーはそれぞれのマシン上に多くて数個のセーブされたゲームを保持していました。プレイヤーが進行させたい場合には、メインサーバーから最新のセーブをダウンロードし、しばらくプレイして、他の人が利用できるように歩人しサーバーにアップロードし直します。


何らかの理由でプレイヤーが、より昔にセーブされたゲームを入手したい場合どうでしょうか？もしかすると現在のセーブされたゲームは、誰かがレベル3に戻ってオブジェクトを拾うのを忘れたために、勝つことができない状態にあり、まだゲームがコンプリート出来うる状態の保存されたゲームを見つけたくなるかもしれません。あるいは過去に保存された2つのゲームを比較して特定のプレイヤーがどれほどの働きをしたかを見たいかもしれません。

古い修正を見たくなる理由はたくさんあるかもしれませんが、その結果は同じです。人々はその保存された古いゲームを中央サーバーに尋ねる必要があります。より多くの保存されたゲームを欲しているならば、より多くのやりとりが必要になります。

Gitもそのメンバーでもある新しい世代のバージョン管理システムは、分散型システムとして知られており、集中型システムの一般化として考えることができます。

特に長い履歴がある場合、初回の複製操作に多くのコストかかるかもしれませんが、長期運用することで効果をもたらすことができます。1つの直接的な利益は、何らかの理由で古いセーブが要求されている場合に、中央サーバーとのやりとりが不要だということです。

=== 愚かな迷信 ===

A popular misconception is that distributed systems are ill-suited for projects requiring an official central repository. Nothing could be further from the truth. Photographing someone does not cause their soul to be stolen. Similarly, cloning the master repository does not diminish its importance.

A good first approximation is that anything a centralized version control system can do, a well-designed distributed system can do better. Network resources are simply costlier than local resources. While we shall later see there are drawbacks to a distributed approach, one is less likely to make erroneous comparisons with this rule of thumb.

A small project may only need a fraction of the features offered by such a
system, but using systems that scale poorly for tiny projects is like using
Roman numerals for calculations involving small numbers.

Moreover, your project may grow beyond your original expectations. Using Git from the outset is like carrying a Swiss army knife even though you mostly use it to open bottles. On the day you desperately need a screwdriver you'll be glad you have more than a plain bottle-opener.

=== Merge Conflicts ===

For this topic, our computer game analogy becomes too thinly stretched. Instead, let us again consider editing a document.

Suppose Alice inserts a line at the beginning of a file, and Bob appends one at the end of his copy. They both upload their changes. Most systems will automatically deduce a reasonable course of action: accept and merge their changes, so both Alice's and Bob's edits are applied.

Now suppose both Alice and Bob have made distinct edits to the same line. Then it is impossible to proceed without human intervention. The second person to upload is informed of a _merge conflict_, and must choose one edit over another, or revise the line entirely.

More complex situations can arise. Version control systems handle the simpler cases themselves, and leave the difficult cases for humans. Usually their behaviour is configurable.
