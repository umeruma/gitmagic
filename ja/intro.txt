== 導入 ==

私はバージョン管理について紹介するために比喩を使います。まともな説明は、 http://en.wikipedia.org/wiki/Revision_control[修正管理についてのウィキペディアの記事]をご覧ください。

=== 仕事は遊び ===

私はコンピュータゲームで遊ぶことに人生のほぼ全てを費やしてきました。それに対して、バージョン管理システムを使い始めたのは大人になってからでした。私に限った話ではないと思いますし、この二つを比べることはそのコンセプトを説明しやすく、また理解しやすくするでしょう。

あなたのコード、またはドキュメントの編集を、ゲームで遊ぶことのように考えてみてください。かつて、たくさん進めてきたのであれば、セーブしたことでしょう。そうするように、あなたは信頼できるエディタの「保存する」ボタンをクリックします。

しかしこれは古いバージョンを上書きます。かつてのオールドスクールゲームに一つのセーブスロットしかなかったようなものです: 当然セーブではきましたが、古い状態に戻ることはもうできませんでした。 それは残念なことでした、あなたの過去のセーブポイントはいつの日かまた戻りたい、ゲームの並外れて楽しい部分のすぐそばだったかもしれません。もっと悪ければ、今のセーブが勝てない状態にあるのであれば、再スタートしなければいけません。

=== バージョン管理 ===

編集しているとき、古いバージョンをとっておきたければ、あなたは別のファイルとして「名前をつけて保存…」したり、保存する前にまずファイルをどこか別の場所へコピーすることができます。省スペースのためにそれらを圧縮することも可能です。これはバージョン管理としては原始的で多くの労力を必要とします。コンピュータゲームは遠い昔にこの問題を改善しており、その多くがタイムスタンプが付いた複数の自動セーブスロットを提供しています。

では問題をより難しくしてみましょう。プロジェクトのソースコードや、ウェブサイトのファイルなど、一緒に扱う多くのファイルがあるとします。すると古いバージョンを保持したいのであれば、ディレクトリ全体をアーカイブしなければいけません。手作業で多くのバージョンを保持するのは不便ですし、すぐに多くのコストがかかるようになります。

いくつかのコンピューターゲームでは、セーブされたゲームは実際にファイルで満ちたディレクトリーで成り立っています。これらのゲームはプレイヤーからその詳細を隠し、このディレクトリの異なるバージョンを管理する便利なインターフェースを提供します。

バージョン管理システムも変わりません。それは色々なものが入ったディレクトリを管理するための素敵なインターフェースを持っています。あなたはディレクトリの状態を頻繁に保存することができ、保存された状態のどれでも後から読み込むことが可能です。ほとんどのコンピューターゲームとは異なり、それらは大抵の場合スペースの節約おいて優れています。一般的に、バージョン間で変更のあるファイルは少数で、そう多くはありません。丸ごと新しくコピーするよりも差分を保持する方が空間が節約されます。

=== 分散型管理 ===

では非常に難しいコンピューターゲームを想像してみましょう。終わらせることが非常に困難であるため、全世界中の多くの経験豊富なゲーマーたちは、力を合わせそれぞれのセーブされたゲームを共有して打ち負かそうと決断しました。スピードランは実際の例です: 同じゲームの異なるレベルに特化したプレイヤーたちが協力することで素晴らしい結果を生み出しています。

どのようにシステムを準備すれば彼らがお互いのセーブを容易に入手できるでしょうか？そして新しいものをアップロードできるでしょうか？

かつては、どのプロジェクトも集中型バージョン管理を利用していました。どこかにあるサーバーがセーブされたゲームのすべて保持していました。その他の場所にはありません。全プレーヤーはそれぞれのマシン上に多くて数個のセーブされたゲームを保持していました。プレイヤーが進行させたい場合には、メインサーバーから最新のセーブをダウンロードし、しばらくプレイして、他の人が利用できるように歩人しサーバーにアップロードし直します。

何らかの理由でプレイヤーが、より昔にセーブされたゲームを入手したい場合どうでしょうか？もしかすると現在のセーブされたゲームは、誰かがレベル3に戻ってオブジェクトを拾うのを忘れたために、勝つことができない状態にあり、まだゲームがコンプリート出来うる状態の保存されたゲームを見つけたくなるかもしれません。あるいは過去に保存された2つのゲームを比較して特定のプレイヤーがどれほどの働きをしたかを見たいかもしれません。

古い修正を見たくなる理由はたくさんあるかもしれませんが、その結果は同じです。人々はその保存された古いゲームを中央サーバーに尋ねる必要があります。より多くの保存されたゲームを欲しているならば、より多くのやりとりが必要になります。

Gitもそのメンバーでもある新しい世代のバージョン管理システムは、分散型システムとして知られており、集中型システムの一般化として考えることができます。

特に長い履歴がある場合、初回の複製操作に多くのコストかかるかもしれませんが、長期運用することで効果をもたらすことができます。1つの直接的な利益は、何らかの理由で古いセーブが要求されている場合に、中央サーバーとのやりとりが不要だということです。

=== 愚かな迷信 ===

よくある誤解なのが、分散型システムは公式の中央リポジトリを必要とするプロジェクトには不適切であるというものです。事実からかけ離れたものがあってはなりません。誰かの写真撮影が、その人たちの魂を奪うことはありません。同じように、マスターリポジトリを複製してもその重要性が損なわれることはありません。

最初の良い近似として、集中型バージョンコントロールシステムができることは何でも、うまく設計された分散型システムはより上手くこなすことができます。ネットワークリソースは単純にローカルリソースよりも高くつきます。後ほど私たちは分散型の手法に欠点があることを知りますが、この経験則と誤った対比をしてしまう可能性は低くなります。

小さいプロジェクトはそのおようなシステムが提供する機能のいちのごく一部しか必要としないかもしれませんが、非常に小さいプロジェクトのためにスケールしないシステムを使うのは、ローマ数字を少数を含む計算に利用するようなものです。

その上、あなたのプロジェクトは当初の予定よりも成長するかもしれません。最初からGitを利用するのは、主にボトルを開けるために使用する場合でもスイスアーミーナイフを携帯するのと同じです。どうしてもスクリュードライバーが必要になったある日、あなたは単なる栓抜き以上のものを持っていたことに喜ぶでしょう。

=== 競合のマージ ===

このトピックには、我々のコンピューターゲームの比喩はあまりにも薄くなりすぎます。それよりも、もう一度書類を編集することを考えてみましょう。

このトピックには、我々のコンピューターゲームの比喩はあまりにも薄くなりすぎます。それよりも、もう一度書類の編集作業を考えてみましょう。

アリスがファイルの冒頭に一行挿入し、ボブが複製されたファイルの終わりに追加しているところを想像してください。彼女らはどちらもその変更をアップロードします。ほとんどのシステムは自動的に合理的な行動手順を推測します。それぞれの変更を許可もしくはマージするので、アリスとボブの変更はどちらも適用されます。

今度はアリスとボブの両方が同じ行に異なる変更を加えた場合を考えてみてください。すると人間の介入なしには進めることができなくなります。アップロードを行う2人目に_マージの競合_が知らされ、片方の変更を選択するか、その行を丸ごと修正し直さなければなりません。

より複雑な状況も発生しうるでしょう。バージョン管理システムは単純な事柄であればそれ自身で対処できますが、難しい事柄は人間に委ねています。通常、その動作は設定が可能になっています。
